// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

// Code generated by dev-tools/cmd/buildlimits/buildlimits.go - DO NOT EDIT.

package config

import (
	"time"

	"github.com/elastic/beats/v7/x-pack/elastic-agent/pkg/packer"
	"github.com/elastic/go-ucfg/yaml"
	"github.com/pbnjay/memory"
	"github.com/pkg/errors"
)

const (
	defaultCacheNumCounters = 500000           // 10x times expected count
	defaultCacheMaxCost     = 50 * 1024 * 1024 // 50MiB cache size

	defaultMaxConnections = 0 // no limit
	defaultPolicyThrottle = time.Millisecond * 5

	defaultCheckinInterval = time.Millisecond
	defaultCheckinBurst    = 1000
	defaultCheckinMax      = 0
	defaultCheckinMaxBody  = 1024 * 1024

	defaultArtifactInterval = time.Millisecond * 5
	defaultArtifactBurst    = 25
	defaultArtifactMax      = 50
	defaultArtifactMaxBody  = 0

	defaultEnrollInterval = time.Millisecond * 10
	defaultEnrollBurst    = 100
	defaultEnrollMax      = 50
	defaultEnrollMaxBody  = 1024 * 512

	defaultAckInterval = time.Millisecond * 10
	defaultAckBurst    = 100
	defaultAckMax      = 50
	defaultAckMaxBody  = 1024 * 1024 * 2
)

type envLimits struct {
	MaxRAM int                  `config:"max_ram"`
	Server *serverLimitDefaults `config:"server_limits"`
	Cache  *cacheLimits         `config:"cache_limits"`
}

func defaultEnvLimits() *envLimits {
	return &envLimits{
		MaxRAM: 0,
		Server: defaultserverLimitDefaults(),
		Cache:  defaultCacheLimits(),
	}
}

type cacheLimits struct {
	NumCounters int64 `config:"num_counters"`
	MaxCost     int64 `config:"max_cost"`
}

func defaultCacheLimits() *cacheLimits {
	return &cacheLimits{
		NumCounters: defaultCacheNumCounters,
		MaxCost:     defaultCacheMaxCost,
	}
}

type limit struct {
	Interval time.Duration `config:"interval"`
	Burst    int           `config:"burst"`
	Max      int64         `config:"max"`
	MaxBody  int64         `config:"max_body_byte_size"`
}

type serverLimitDefaults struct {
	PolicyThrottle time.Duration `config:"policy_throttle"`
	MaxConnections int           `config:"max_connections"`

	CheckinLimit  limit `config:"checkin_limit"`
	ArtifactLimit limit `config:"artifact_limit"`
	EnrollLimit   limit `config:"enroll_limit"`
	AckLimit      limit `config:"ack_limit"`
}

func defaultserverLimitDefaults() *serverLimitDefaults {
	return &serverLimitDefaults{
		PolicyThrottle: defaultCacheNumCounters,
		MaxConnections: defaultCacheMaxCost,

		CheckinLimit: limit{
			Interval: defaultCheckinInterval,
			Burst:    defaultCheckinBurst,
			Max:      defaultCheckinMax,
			MaxBody:  defaultCheckinMaxBody,
		},
		ArtifactLimit: limit{
			Interval: defaultArtifactInterval,
			Burst:    defaultArtifactBurst,
			Max:      defaultArtifactMax,
			MaxBody:  defaultArtifactMaxBody,
		},
		EnrollLimit: limit{
			Interval: defaultEnrollInterval,
			Burst:    defaultEnrollBurst,
			Max:      defaultEnrollMax,
			MaxBody:  defaultEnrollMaxBody,
		},
		AckLimit: limit{
			Interval: defaultAckInterval,
			Burst:    defaultAckBurst,
			Max:      defaultAckMax,
			MaxBody:  defaultAckMaxBody,
		},
	}
}

var defaults []*envLimits

func init() {
	// Packed Files
	// internal/pkg/config/defaults/1024_limits.yml
	// internal/pkg/config/defaults/2048_limits.yml
	// internal/pkg/config/defaults/4096_limits.yml
	// internal/pkg/config/defaults/512_limits.yml
	// internal/pkg/config/defaults/8192_limits.yml
	// internal/pkg/config/defaults/max_limits.yml
	unpacked := packer.MustUnpack("eJzElt2PqjgYxu/3z5jrzQ6tYo6bnIsqinDSGg3ydbOhMIJM+ciI8rHZ/31TFXdmYBBONjmXVvK0fZ/f+7z9++kQZy9vscOe01f/2U3i/cF/9l72zollx2cgwPFf7BAdsuMfZcSe/nyixnJsjtSAaomPNVQSlIaWQRJbnx4dA6TeCk/mB+TTWM9MSM6eIQq2qVbrAyqxhHKMEl+RQfCynIZ0RITr+usIa7sSo7SyTRXaprqnMsscc1ut/cRXVrMzlVn4ok8FZ6WevdX2aGuJT7RZ5ubv9KB4sg0iOMb05FaJT6p6P5LYBnlzDPGmu7mcUZnPUhpvmRvbAZUSnxiguq0fPFOtPL6mofy2llmmP1GkXY6lxQ9lPgvceJva0TL0lre7S4n/87qLHEuI6zIaq2cqF/ezKvwOc+Q711pCy8gniqTk1MQ/+Loiq8CNL7UE+PYt92l9QMVNM7Bg1n13ufcZvz/93k0NFMbfOqgJkbDuT43wBTXgZ6nBD6jBGqqdCB1ZDx3ITiYsUmow4aLbcEK96s2Rb8V66Y4279xE1314Natdjjd832XpySyyDCLcdQ/1t+zkyXrpRcsj74wWh7mjn1xRBpKzaCOn+HxeHF73sQzy9n/cn+th9P0hPWNhOvmaHiIhkfi96Rl/QU+Bpc2YaC7kp3Qhr7he1rd0q4RXM6ewSK0R23tyUNLRVqDybqJIejc94VB6li3VU5rVu1A5LHdwS+5cXfiQEUJNlG2IJYXF8QGVBW7JCtzICuVW92XogPs5W/VaaCyblG96ZY8IYAc82qKcRySwYMA+mX3yDLC34BRcC4jft1VmmQH/ry6gSKoFwP7A2AnRre3ueica6aEnszO97LcYNqzqGPsIDmgENhoUOQWW2nQXjUEwCJhWzd1nwHsNKtx+7wZ8j0D5BqYdpKylhYj7x0xB/mv7dlp4mMaE34K57KOeK/PfRDRH28SNpoInF4wPuG5a8L1FOM0WzFLKOtsMYGkGmpXbtESNAgY/cTSUe802Fppt7P/iYbXL8UpvPnWkRixeRscjiiKn6HofuwWpXsckfC3W0uaHBZd8JnyMC1kEVOdzSb+YdX2BWHlduIseJOca8zXX1Hi2Doyf6JrZtR6NRGaNtimFIge4us+F3vHT1/AFwBIqLuaYquAYdmCNtg9MH2bSL5xdvZtqLd1eP//89m8AAAD//28oht4=")

	for f, v := range unpacked {
		cfg, err := yaml.NewConfig(v, DefaultOptions...)
		if err != nil {
			panic(errors.Wrap(err, "Cannot read spec from "+f))
		}

		l := defaultEnvLimits()
		if err := cfg.Unpack(&l, DefaultOptions...); err != nil {
			panic(errors.Wrap(err, "Cannot unpack spec from "+f))
		}

		defaults = append(defaults, l)
	}
}

func loadLimits() *envLimits {
	ramSize := int(memory.TotalMemory() / 1024 / 1024)
	return loadLimitsForRam(ramSize)
}

func loadLimitsForRam(currentRAM int) *envLimits {
	var lastLimits *envLimits

	for _, l := range defaults {
		// get max possible config for current env
		if currentRAM > l.MaxRAM || (lastLimits != nil && l.MaxRAM > 0 && lastLimits.MaxRAM < l.MaxRAM) {
			continue
		}
		lastLimits = l
	}

	if lastLimits == nil {
		return defaultEnvLimits()
	}
	return lastLimits
}
