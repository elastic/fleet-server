// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

const (
	AgentApiKeyScopes = "agentApiKey.Scopes"
	ApiKeyScopes      = "apiKey.Scopes"
)

// Defines values for ActionType.
const (
	CANCEL             ActionType = "CANCEL"
	INPUTACTION        ActionType = "INPUT_ACTION"
	POLICYCHANGE       ActionType = "POLICY_CHANGE"
	POLICYREASSIGN     ActionType = "POLICY_REASSIGN"
	REQUESTDIAGNOSTICS ActionType = "REQUEST_DIAGNOSTICS"
	SETTINGS           ActionType = "SETTINGS"
	UNENROLL           ActionType = "UNENROLL"
	UPGRADE            ActionType = "UPGRADE"
)

// Defines values for ActionRequestDiagnosticsAdditionalMetrics.
const (
	CPU ActionRequestDiagnosticsAdditionalMetrics = "CPU"
)

// Defines values for ActionSettingsLogLevel.
const (
	ActionSettingsLogLevelDebug   ActionSettingsLogLevel = "debug"
	ActionSettingsLogLevelError   ActionSettingsLogLevel = "error"
	ActionSettingsLogLevelInfo    ActionSettingsLogLevel = "info"
	ActionSettingsLogLevelWarning ActionSettingsLogLevel = "warning"
)

// Defines values for CheckinRequestStatus.
const (
	CheckinRequestStatusDegraded CheckinRequestStatus = "degraded"
	CheckinRequestStatusError    CheckinRequestStatus = "error"
	CheckinRequestStatusOnline   CheckinRequestStatus = "online"
	CheckinRequestStatusStarting CheckinRequestStatus = "starting"
)

// Defines values for EnrollRequestType.
const (
	PERMANENT EnrollRequestType = "PERMANENT"
)

// Defines values for EventSubtype.
const (
	ACKNOWLEDGED EventSubtype = "ACKNOWLEDGED"
	CONFIG       EventSubtype = "CONFIG"
	DATADUMP     EventSubtype = "DATA_DUMP"
	FAILED       EventSubtype = "FAILED"
	INPROGRESS   EventSubtype = "IN_PROGRESS"
	RUNNING      EventSubtype = "RUNNING"
	STARTING     EventSubtype = "STARTING"
	STOPPED      EventSubtype = "STOPPED"
	STOPPING     EventSubtype = "STOPPING"
	UNKNOWN      EventSubtype = "UNKNOWN"
)

// Defines values for EventType.
const (
	ACTION       EventType = "ACTION"
	ACTIONRESULT EventType = "ACTION_RESULT"
	ERROR        EventType = "ERROR"
	STATE        EventType = "STATE"
)

// Defines values for StatusResponseStatus.
const (
	Configuring StatusResponseStatus = "configuring"
	Degraded    StatusResponseStatus = "degraded"
	Failed      StatusResponseStatus = "failed"
	Healthy     StatusResponseStatus = "healthy"
	Starting    StatusResponseStatus = "starting"
	Stopped     StatusResponseStatus = "stopped"
	Stopping    StatusResponseStatus = "stopping"
	Unknown     StatusResponseStatus = "unknown"
)

// Defines values for UpgradeDetailsState.
const (
	UpgradeDetailsStateUPGDOWNLOADING UpgradeDetailsState = "UPG_DOWNLOADING"
	UpgradeDetailsStateUPGEXTRACTING  UpgradeDetailsState = "UPG_EXTRACTING"
	UpgradeDetailsStateUPGFAILED      UpgradeDetailsState = "UPG_FAILED"
	UpgradeDetailsStateUPGREPLACING   UpgradeDetailsState = "UPG_REPLACING"
	UpgradeDetailsStateUPGREQUESTED   UpgradeDetailsState = "UPG_REQUESTED"
	UpgradeDetailsStateUPGRESTARTING  UpgradeDetailsState = "UPG_RESTARTING"
	UpgradeDetailsStateUPGROLLBACK    UpgradeDetailsState = "UPG_ROLLBACK"
	UpgradeDetailsStateUPGSCHEDULED   UpgradeDetailsState = "UPG_SCHEDULED"
	UpgradeDetailsStateUPGWATCHING    UpgradeDetailsState = "UPG_WATCHING"
)

// Defines values for UpgradeMetadataFailedFailedState.
const (
	UpgradeMetadataFailedFailedStateUPGDOWNLOADING UpgradeMetadataFailedFailedState = "UPG_DOWNLOADING"
	UpgradeMetadataFailedFailedStateUPGEXTRACTING  UpgradeMetadataFailedFailedState = "UPG_EXTRACTING"
	UpgradeMetadataFailedFailedStateUPGREPLACING   UpgradeMetadataFailedFailedState = "UPG_REPLACING"
	UpgradeMetadataFailedFailedStateUPGREQUESTED   UpgradeMetadataFailedFailedState = "UPG_REQUESTED"
	UpgradeMetadataFailedFailedStateUPGRESTARTING  UpgradeMetadataFailedFailedState = "UPG_RESTARTING"
	UpgradeMetadataFailedFailedStateUPGSCHEDULED   UpgradeMetadataFailedFailedState = "UPG_SCHEDULED"
	UpgradeMetadataFailedFailedStateUPGWATCHING    UpgradeMetadataFailedFailedState = "UPG_WATCHING"
)

// Defines values for UploadBeginRequestSrc.
const (
	Agent    UploadBeginRequestSrc = "agent"
	Endpoint UploadBeginRequestSrc = "endpoint"
)

// AckRequest The request an elastic-agent sends to fleet-serve to acknowledge the execution of one or more actions.
type AckRequest struct {
	Events []AckRequest_Events_Item `json:"events"`
}

// AckRequest_Events_Item defines model for ackRequest.events.Item.
type AckRequest_Events_Item struct {
	union json.RawMessage
}

// AckResponse Response to processing acknowledgement events.
type AckResponse struct {
	// Action The action result. Will have the value "acks".
	Action string `json:"action"`

	// Errors A flag to indicate if one or more errors occured when proccessing events.
	Errors bool `json:"errors,omitempty"`

	// Items The in-order list of results from processing events.
	Items []AckResponseItem `json:"items,omitempty"`
}

// AckResponseItem The results of processing an acknowledgement event.
type AckResponseItem struct {
	// Message HTTP status text.
	Message *string `json:"message,omitempty"`

	// Status An HTTP status code that indicates if the event was processed successfully or not.
	Status int `json:"status"`
}

// Action An action for an elastic-agent.
// The structure of the `data` attribute will vary between action types.
// model/schema.json has a looser definition of actions and it define's fleet-server's interactions with Elasticsearch when retrieving actions.
type Action struct {
	// AgentId The agent ID.
	AgentId string `json:"agent_id"`

	// CreatedAt Time when the action was created.
	CreatedAt string `json:"created_at"`

	// Data An embedded action-specific object.
	Data Action_Data `json:"data" yaml:"data"`

	// Expiration The latest start time for the action. Actions will be dropped by the agent if execution has not started by this time. Used for scheduled actions.
	Expiration *string `json:"expiration,omitempty" yaml:"expiration"`

	// Id The action ID.
	Id string `json:"id" yaml:"action_id"`

	// InputType The input type of the action for actions with type `INPUT_ACTION`.
	InputType string `json:"input_type" yaml:"input_type"`

	// Signed Optional action signing data.
	Signed *ActionSignature `json:"signed,omitempty" yaml:"signed"`

	// StartTime The earliest execution time for the action. Agent will not execute the action before this time. Used for scheduled actions.
	StartTime *string `json:"start_time,omitempty" yaml:"start_time"`

	// Timeout The timeout value (in seconds) for actions with type `INPUT_ACTION`.
	Timeout *int64 `json:"timeout,omitempty" yaml:"timeout"`

	// Traceparent APM traceparent for the action.
	Traceparent *string `json:"traceparent,omitempty" yaml:"traceparent"`

	// Type The action type. If fleet-server encounters an action that does not have a type listed below it will be filtered out and an error will be logged.
	Type ActionType `json:"type" yaml:"type"`
}

// Action_Data An embedded action-specific object.
type Action_Data struct {
	union json.RawMessage
}

// ActionType The action type. If fleet-server encounters an action that does not have a type listed below it will be filtered out and an error will be logged.
type ActionType string

// ActionCancel The CANCEL action data.
type ActionCancel struct {
	TargetId string `json:"target_id"`
}

// ActionInputAction The INPUT_ACTION action data.
type ActionInputAction = map[string]interface{}

// ActionPolicyChange The POLICY_CHANGE action data.
type ActionPolicyChange struct {
	// Policy The full policy that an agent should run after combining with local configuration/env vars.
	Policy PolicyData `json:"policy"`
}

// ActionPolicyReassign The POLICY_REASSIGN action data.
type ActionPolicyReassign struct {
	PolicyId string `json:"policy_id"`
}

// ActionRequestDiagnostics The REQUEST_DIAGNOSTICS action data.
type ActionRequestDiagnostics struct {
	// AdditionalMetrics list optional additional metrics.
	AdditionalMetrics *[]ActionRequestDiagnosticsAdditionalMetrics `json:"additional_metrics,omitempty"`
}

// ActionRequestDiagnosticsAdditionalMetrics defines model for ActionRequestDiagnostics.AdditionalMetrics.
type ActionRequestDiagnosticsAdditionalMetrics string

// ActionSettings The SETTINGS action data.
type ActionSettings struct {
	LogLevel *ActionSettingsLogLevel `json:"log_level,omitempty"`
}

// ActionSettingsLogLevel defines model for ActionSettings.LogLevel.
type ActionSettingsLogLevel string

// ActionSignature Optional action signing data.
type ActionSignature struct {
	// Data The base64 encoded, UTF-8 JSON serialized action bytes that are signed.
	Data string `json:"data,omitempty" yaml:"data"`

	// Signature The base64 encoded signature.
	Signature string `json:"signature,omitempty" yaml:"signature"`
}

// ActionUnenroll The UNENROLL action data.
type ActionUnenroll = interface{}

// ActionUpgrade the UPGRADE action data.
type ActionUpgrade struct {
	// SourceUri The source of the upgrade artifact.
	SourceUri *string `json:"source_uri,omitempty"`

	// Version The version number that the agent should upgrade to.
	Version string `json:"version"`
}

// CheckinRequest defines model for checkinRequest.
type CheckinRequest struct {
	// AckToken The ack_token form a previous response if the agent has checked in before.
	// Translated to a sequence number in fleet-server in order to retrieve any new actions for the agent from the last checkin.
	AckToken *string `json:"ack_token,omitempty"`

	// Components An embedded JSON object that holds component information that the agent is running.
	// Defined in fleet-server as a `json.RawMessage`, defined as an object in the elastic-agent.
	// fleet-server will update the components in an agent record if they differ from this object.
	Components *json.RawMessage `json:"components,omitempty"`

	// LocalMetadata An embedded JSON object that holds meta-data values.
	// Defined in fleet-server as a `json.RawMessage`, defined as an object in the elastic-agent.
	// elastic-agent will populate the object with information from the binary and host/system environment.
	// fleet-server will update the agent record if a checkin response contains different data from the record.
	LocalMetadata *json.RawMessage `json:"local_metadata,omitempty"`

	// Message State message, may be overridden or use the error message of a failing component.
	Message string `json:"message"`

	// PollTimeout An optional timeout value that informs fleet-server of when a client will time out on it's checkin request.
	// If not specified fleet-server will use the timeout values specified in the config (defaults to 5m polling and a 10m write timeout).
	// The value, if specified is expected to be a string that is parsable by [time.ParseDuration](https://pkg.go.dev/time#ParseDuration).
	// If specified fleet-server will set its poll timeout to `max(1m, poll_timeout-2m)` and its write timeout to `max(2m, poll_timout-1m)`.
	PollTimeout *string `json:"poll_timeout,omitempty"`

	// Status The agent state, inferred from agent control protocol states.
	Status CheckinRequestStatus `json:"status"`

	// UpgradeDetails Additional details describing the status of an UPGRADE action delivered by the client (agent) on checkin.
	UpgradeDetails *UpgradeDetails `json:"upgrade_details,omitempty"`
}

// CheckinRequestStatus The agent state, inferred from agent control protocol states.
type CheckinRequestStatus string

// CheckinResponse defines model for checkinResponse.
type CheckinResponse struct {
	// AckToken The acknowlegment token used to indicate action delivery.
	AckToken *string `json:"ack_token,omitempty"`

	// Action The action result. Set to "checkin".
	Action string `json:"action"`

	// Actions A list of actions that the agent must execute.
	Actions *[]Action `json:"actions,omitempty"`
}

// DiagnosticsEvent defines model for diagnosticsEvent.
type DiagnosticsEvent struct {
	// ActionId The action ID.
	ActionId string `json:"action_id"`

	// AgentId The ID of the agent that executed the action.
	AgentId string `json:"agent_id"`
	Data    *struct {
		// UploadId The upload ID for the diagnostics bundle.
		UploadId string `json:"upload_id"`
	} `json:"data,omitempty"`

	// Error An error message.
	// If this is non-empty an error has occured when executing the action.
	// For some actions (such as UPGRADE actions) it may result in the action being marked as failed.
	Error *string `json:"error,omitempty"`

	// Message An acknowlegement message. The elastic-agent inserts the action ID and action type into this message.
	Message string `json:"message"`

	// Subtype The subtype of the ack event.
	// The elastic-agent will only generate ACKNOWLEDGED events.
	//
	// Not used by fleet-server.
	// Actions that have errored should use the error attribute to communicate an error status.
	// Additional action status information can be provided in the data attribute.
	// Deprecated:
	Subtype EventSubtype `json:"subtype"`

	// Timestamp The timestamp of the acknowledgement event. Has the format of "2006-01-02T15:04:05.99999-07:00"
	Timestamp time.Time `json:"timestamp"`

	// Type The event type of the ack.
	// Currently the elastic-agent will only generate ACTION_RESULT events.
	//
	// Not used by fleet-server.
	// Actions that have errored should use the error attribute to communicate an error status.
	// Additional action status information can be provided in the data attribute.
	// Deprecated:
	Type EventType `json:"type"`
}

// EnrollMetadata Metadata associated with the agent that is enrolling to fleet.
type EnrollMetadata struct {
	// Local An embedded JSON object that holds meta-data values.
	// Defined in fleet-server as a `json.RawMessage`, defined as an object in the elastic-agent.
	// elastic-agent will populate the object with information from the binary and host/system environment.
	// If not empty fleet-server will update the value of `local["elastic"]["agent"]["id"]` to the agent ID (assuming the keys exist).
	// The (possibly updated) value is sent by fleet-server when creating the record for a new agent.
	Local json.RawMessage `json:"local"`

	// Tags User provided tags for the agent.
	// fleet-server will pass the tags to the agent record on enrollment.
	Tags []string `json:"tags"`

	// UserProvided An embedded JSON object that holds user-provided meta-data values.
	// Defined in fleet-server as a `json.RawMessage`.
	// fleet-server does not use these values on enrollment of an agent.
	//
	// Defined in the elastic-agent as a `map[string]interface{}` with no way to specify any values.
	// Deprecated:
	UserProvided json.RawMessage `json:"user_provided"`
}

// EnrollRequest A request to enroll a new agent into fleet.
type EnrollRequest struct {
	// EnrollmentId The enrollment ID of the agent.
	// To replace an agent on enroll fail.
	// The existing agent with a matching enrollment_id will be deleted if it never checked in. The new agent will be enrolled with the enrollment_id.
	EnrollmentId *string `json:"enrollment_id,omitempty"`

	// Metadata Metadata associated with the agent that is enrolling to fleet.
	Metadata EnrollMetadata `json:"metadata"`

	// SharedId The shared ID of the agent.
	// To support pre-existing installs.
	//
	// Never implemented.
	// Deprecated:
	SharedId *string `json:"shared_id,omitempty"`

	// Type The enrollment type of the agent.
	// The agent only supports the PERMANENT value.
	// In the future the enrollment type may be used to indicate agents that use fleet for reporting and monitoring, but do not use policies.
	Type EnrollRequestType `json:"type"`
}

// EnrollRequestType The enrollment type of the agent.
// The agent only supports the PERMANENT value.
// In the future the enrollment type may be used to indicate agents that use fleet for reporting and monitoring, but do not use policies.
type EnrollRequestType string

// EnrollResponse The enrollment action response.
type EnrollResponse struct {
	// Action The action result. Will have the value "created".
	Action string `json:"action"`

	// Item Response to a successful enrollment of an agent into fleet.
	Item EnrollResponseItem `json:"item"`
}

// EnrollResponseItem Response to a successful enrollment of an agent into fleet.
type EnrollResponseItem struct {
	// AccessApiKey The ApiKey token that fleet-server has generated for the enrolling agent.
	AccessApiKey string `json:"access_api_key"`

	// AccessApiKeyId The id of the ApiKey that fleet-server has generated for the enrolling agent.
	AccessApiKeyId string `json:"access_api_key_id"`

	// Actions Defined in fleet-server and elastic-agent as `[]interface{}`.
	//
	// Never used by agent.
	// Deprecated:
	Actions []map[string]interface{} `json:"actions"`

	// Active If the agent is active in fleet.
	// Set to true upon enrollment.
	//
	// Handling of other values never implemented.
	// Deprecated:
	Active bool `json:"active"`

	// EnrolledAt The RFC3339 timestamp that the agent was enrolled at.
	EnrolledAt string `json:"enrolled_at"`

	// Id The agent ID
	Id string `json:"id"`

	// LocalMetadata A copy of the (updated) local metadata provided in the enrollment request.
	//
	// Never used by agent.
	// Deprecated:
	LocalMetadata json.RawMessage `json:"local_metadata"`

	// PolicyId The policy ID that the agent is enrolled with. Decoded from the API key used in the request.
	PolicyId string `json:"policy_id"`

	// Status Agent status from fleet-server.
	// fleet-ui may differ.
	//
	// Never used by agent.
	// Deprecated:
	Status string `json:"status"`

	// Tags A copy of the tags that were sent with the enrollment request.
	Tags []string `json:"tags"`

	// Type The enrollment request type.
	//
	// Handling of other values never implemented.
	// Deprecated:
	Type string `json:"type"`

	// UserProvidedMetadata A copy of the user provided metadata from the enrollment request.
	//
	// Currently will be empty.
	// Deprecated:
	UserProvidedMetadata json.RawMessage `json:"user_provided_metadata"`
}

// Error Error processing request.
type Error struct {
	// Error Error type.
	Error string `json:"error"`

	// Message (optional) Error message.
	Message *string `json:"message,omitempty"`

	// StatusCode The HTTP status code of the error.
	StatusCode int `json:"statusCode"`
}

// EventSubtype The subtype of the ack event.
// The elastic-agent will only generate ACKNOWLEDGED events.
//
// Not used by fleet-server.
// Actions that have errored should use the error attribute to communicate an error status.
// Additional action status information can be provided in the data attribute.
type EventSubtype string

// EventType The event type of the ack.
// Currently the elastic-agent will only generate ACTION_RESULT events.
//
// Not used by fleet-server.
// Actions that have errored should use the error attribute to communicate an error status.
// Additional action status information can be provided in the data attribute.
type EventType string

// GenericEvent A generic ack event for an action. Includes an optional error attribute.
type GenericEvent struct {
	// ActionId The action ID.
	ActionId string `json:"action_id"`

	// AgentId The ID of the agent that executed the action.
	AgentId string `json:"agent_id"`

	// Error An error message.
	// If this is non-empty an error has occured when executing the action.
	// For some actions (such as UPGRADE actions) it may result in the action being marked as failed.
	Error *string `json:"error,omitempty"`

	// Message An acknowlegement message. The elastic-agent inserts the action ID and action type into this message.
	Message string `json:"message"`

	// Subtype The subtype of the ack event.
	// The elastic-agent will only generate ACKNOWLEDGED events.
	//
	// Not used by fleet-server.
	// Actions that have errored should use the error attribute to communicate an error status.
	// Additional action status information can be provided in the data attribute.
	// Deprecated:
	Subtype EventSubtype `json:"subtype"`

	// Timestamp The timestamp of the acknowledgement event. Has the format of "2006-01-02T15:04:05.99999-07:00"
	Timestamp time.Time `json:"timestamp"`

	// Type The event type of the ack.
	// Currently the elastic-agent will only generate ACTION_RESULT events.
	//
	// Not used by fleet-server.
	// Actions that have errored should use the error attribute to communicate an error status.
	// Additional action status information can be provided in the data attribute.
	// Deprecated:
	Type EventType `json:"type"`
}

// InputEvent defines model for inputEvent.
type InputEvent struct {
	// ActionData The action data for the input action being acknowledged.
	ActionData json.RawMessage `json:"action_data"`

	// ActionId The action ID.
	ActionId string `json:"action_id"`

	// ActionInputType The input_type of the action for input actions.
	ActionInputType string `json:"action_input_type"`

	// ActionResponse The action response for the input action being acknowledged.
	ActionResponse json.RawMessage `json:"action_response"`

	// AgentId The ID of the agent that executed the action.
	AgentId string `json:"agent_id"`

	// CompletedAt The time at which the action was completed.
	CompletedAt time.Time `json:"completed_at"`

	// Error An error message.
	// If this is non-empty an error has occured when executing the action.
	// For some actions (such as UPGRADE actions) it may result in the action being marked as failed.
	Error *string `json:"error,omitempty"`

	// Message An acknowlegement message. The elastic-agent inserts the action ID and action type into this message.
	Message string `json:"message"`

	// StartedAt The time at which the action was started.
	StartedAt time.Time `json:"started_at"`

	// Subtype The subtype of the ack event.
	// The elastic-agent will only generate ACKNOWLEDGED events.
	//
	// Not used by fleet-server.
	// Actions that have errored should use the error attribute to communicate an error status.
	// Additional action status information can be provided in the data attribute.
	// Deprecated:
	Subtype EventSubtype `json:"subtype"`

	// Timestamp The timestamp of the acknowledgement event. Has the format of "2006-01-02T15:04:05.99999-07:00"
	Timestamp time.Time `json:"timestamp"`

	// Type The event type of the ack.
	// Currently the elastic-agent will only generate ACTION_RESULT events.
	//
	// Not used by fleet-server.
	// Actions that have errored should use the error attribute to communicate an error status.
	// Additional action status information can be provided in the data attribute.
	// Deprecated:
	Type EventType `json:"type"`
}

// PolicyData The full policy that an agent should run after combining with local configuration/env vars.
type PolicyData struct {
	// Agent Agent configuration details associated with the policy. May include configuration toggling monitoring, uninstallation protection, etc.
	Agent *map[string]interface{} `json:"agent,omitempty"`

	// Fleet Agent configuration to describe how to connect to fleet-server.
	Fleet *map[string]interface{} `json:"fleet,omitempty"`

	// Id The policy's ID.
	Id *string `json:"id,omitempty"`

	// Inputs A list of all inputs that the agent should run.
	Inputs *[]map[string]interface{} `json:"inputs,omitempty"`

	// OutputPermissions Elasticsearch permissions that the agent requires in order to run the policy.
	OutputPermissions *map[string]interface{} `json:"output_permissions,omitempty"`

	// Outputs A map of all outputs that the agent running the policy can use to send data to.
	Outputs *map[string]interface{} `json:"outputs,omitempty"`

	// Revision The revision number of the policy. Should match revision_idx.
	Revision *int `json:"revision,omitempty"`

	// Signed Optional action signing data.
	Signed *ActionSignature `json:"signed,omitempty" yaml:"signed"`
}

// StatusAPIResponse Status response information.
type StatusAPIResponse struct {
	// Name Service name.
	Name string `json:"name"`

	// Status A Unit state that fleet-server may report.
	// Unit state is defined in the elastic-agent-client specification.
	Status StatusResponseStatus `json:"status"`

	// Version Version information included in the response to an authorized status request.
	Version *StatusResponseVersion `json:"version,omitempty"`
}

// StatusResponseStatus A Unit state that fleet-server may report.
// Unit state is defined in the elastic-agent-client specification.
type StatusResponseStatus string

// StatusResponseVersion Version information included in the response to an authorized status request.
type StatusResponseVersion struct {
	// BuildHash The commit that the fleet-server was built from.
	BuildHash *string `json:"build_hash,omitempty"`

	// BuildTime The date-time that the fleet-server binary was created.
	BuildTime *string `json:"build_time,omitempty"`

	// Number The fleet-server version.
	Number *string `json:"number,omitempty"`
}

// UpgradeEvent defines model for upgradeEvent.
type UpgradeEvent struct {
	// ActionId The action ID.
	ActionId string `json:"action_id"`

	// AgentId The ID of the agent that executed the action.
	AgentId string `json:"agent_id"`

	// Error An error message.
	// If this is non-empty an error has occured when executing the action.
	// For some actions (such as UPGRADE actions) it may result in the action being marked as failed.
	Error *string `json:"error,omitempty"`

	// Message An acknowlegement message. The elastic-agent inserts the action ID and action type into this message.
	Message string `json:"message"`

	// Payload If the payload is part of an upgrade event action ack it will include information about if the agent  will retry the upgrade.
	// Payload is only used by upgrade acks and has been replaced in more recent versions by the checkin's upgrade_details attribute.
	// Deprecated:
	Payload *struct {
		// Retry If the agent will retry the upgrade or not.
		Retry bool `json:"retry"`

		// RetryAttempt The number of attempts the agent has made so far, -1 indicates no future attempts and that the upgrade has failed.
		RetryAttempt int `json:"retry_attempt"`
	} `json:"payload,omitempty"`

	// Subtype The subtype of the ack event.
	// The elastic-agent will only generate ACKNOWLEDGED events.
	//
	// Not used by fleet-server.
	// Actions that have errored should use the error attribute to communicate an error status.
	// Additional action status information can be provided in the data attribute.
	// Deprecated:
	Subtype EventSubtype `json:"subtype"`

	// Timestamp The timestamp of the acknowledgement event. Has the format of "2006-01-02T15:04:05.99999-07:00"
	Timestamp time.Time `json:"timestamp"`

	// Type The event type of the ack.
	// Currently the elastic-agent will only generate ACTION_RESULT events.
	//
	// Not used by fleet-server.
	// Actions that have errored should use the error attribute to communicate an error status.
	// Additional action status information can be provided in the data attribute.
	// Deprecated:
	Type EventType `json:"type"`
}

// UpgradeDetails Additional details describing the status of an UPGRADE action delivered by the client (agent) on checkin.
type UpgradeDetails struct {
	// ActionId The upgrade action ID the details are associated with.
	ActionId string `json:"action_id"`

	// Metadata Upgrade status metadata. Determined by state.
	Metadata *UpgradeDetails_Metadata `json:"metadata,omitempty"`

	// State The upgrade state.
	State UpgradeDetailsState `json:"state"`

	// TargetVersion The version the agent should upgrade to.
	TargetVersion string `json:"target_version"`
}

// UpgradeDetails_Metadata Upgrade status metadata. Determined by state.
type UpgradeDetails_Metadata struct {
	union json.RawMessage
}

// UpgradeDetailsState The upgrade state.
type UpgradeDetailsState string

// UpgradeMetadataDownloading Upgrade metadata for an upgrade that is downloading.
type UpgradeMetadataDownloading struct {
	// DownloadPercent The artifact download progress as a percentage.
	DownloadPercent float64 `json:"download_percent"`

	// DownloadRate The artifact download rate as bytes per second.
	DownloadRate *float64 `json:"download_rate,omitempty"`

	// RetryErrorMsg The error message that is a result of a retryable upgrade download failure.
	RetryErrorMsg *string `json:"retry_error_msg,omitempty"`

	// RetryUntil The RFC3339 timestamp of the deadline the upgrade download is retried until.
	RetryUntil *time.Time `json:"retry_until,omitempty"`
}

// UpgradeMetadataFailed Upgrade metadata for an upgrade that has failed.
type UpgradeMetadataFailed struct {
	// ErrorMsg The error message associated with a failed state.
	ErrorMsg string `json:"error_msg"`

	// FailedState The state where the upgrade failed.
	FailedState UpgradeMetadataFailedFailedState `json:"failed_state"`
}

// UpgradeMetadataFailedFailedState The state where the upgrade failed.
type UpgradeMetadataFailedFailedState string

// UpgradeMetadataScheduled Upgrade metadata for an upgrade that has been scheduled.
type UpgradeMetadataScheduled struct {
	// ScheduledAt The RFC3339 timestamp the upgrade is scheduled to start at.
	ScheduledAt time.Time `json:"scheduled_at"`
}

// UploadBeginRequest defines model for uploadBeginRequest.
type UploadBeginRequest struct {
	// ActionId ID of the action that requested this file
	ActionId string `json:"action_id"`

	// AgentId Identifier of the agent uploading. Matches the ID usually found in agent.id
	AgentId string                  `json:"agent_id"`
	File    UploadBeginRequest_File `json:"file"`

	// Src The source integration sending this file
	Src                  UploadBeginRequestSrc  `json:"src"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UploadBeginRequest_File defines model for UploadBeginRequest.File.
type UploadBeginRequest_File struct {
	// Compression The algorithm used to compress the file. Valid values: br,gzip,deflate,none
	Compression *string `json:"Compression,omitempty"`

	// Hash Checksums on the file contents
	Hash *struct {
		// Sha256 SHA256 of the contents
		Sha256 *string `json:"sha256,omitempty"`
	} `json:"hash,omitempty"`

	// MimeType MIME type of the file
	MimeType string `json:"mime_type"`

	// Name Name of the file including the extension, without the directory
	Name string `json:"name"`

	// Size Size of the file contents, in bytes
	Size                 int64                  `json:"size"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UploadBeginRequestSrc The source integration sending this file
type UploadBeginRequestSrc string

// UploadBeginAPIResponse Response to initiating a file upload
type UploadBeginAPIResponse struct {
	// ChunkSize The required size (in bytes) that the file must be segmented into for each chunk
	ChunkSize int64 `json:"chunk_size"`

	// UploadId A unique identifier for the ensuing upload operation
	UploadId string `json:"upload_id"`
}

// UploadCompleteRequest Request to verify and finish an uploaded file
type UploadCompleteRequest struct {
	// Transithash the transithash (sha256 of the concatenation of each in-order chunk hash) of the entire file contents
	Transithash struct {
		// Sha256 SHA256 hash
		Sha256 string `json:"sha256"`
	} `json:"transithash"`
}

// ApiVersion defines model for apiVersion.
type ApiVersion = string

// RequestId defines model for requestId.
type RequestId = string

// UserAgent defines model for userAgent.
type UserAgent = string

// AgentNotFound Error processing request.
type AgentNotFound = Error

// BadRequest Error processing request.
type BadRequest = Error

// Deadline Error processing request.
type Deadline = Error

// Forbidden Error processing request.
type Forbidden = Error

// InternalServerError Error processing request.
type InternalServerError = Error

// KeyNotEnabled Error processing request.
type KeyNotEnabled = Error

// Throttle Error processing request.
type Throttle = Error

// Unavailable Error processing request.
type Unavailable = Error

// GetPGPKeyParams defines parameters for GetPGPKey.
type GetPGPKeyParams struct {
	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`

	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`
}

// AgentEnrollParams defines parameters for AgentEnroll.
type AgentEnrollParams struct {
	// UserAgent The user-agent header that is sent.
	// Must have the format "elastic agent X.Y.Z" where "X.Y.Z" indicates the agent version.
	// The agent version must not be greater than the version of the fleet-server.
	UserAgent UserAgent `json:"User-Agent"`

	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`

	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`
}

// AgentAcksParams defines parameters for AgentAcks.
type AgentAcksParams struct {
	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`

	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`
}

// AgentCheckinParams defines parameters for AgentCheckin.
type AgentCheckinParams struct {
	// AcceptEncoding If the agent is able to accept encoded responses.
	// Used to indicate if GZIP compression may be used by the server.
	// The elastic-agent does not use the accept-encoding header.
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// UserAgent The user-agent header that is sent.
	// Must have the format "elastic agent X.Y.Z" where "X.Y.Z" indicates the agent version.
	// The agent version must not be greater than the version of the fleet-server.
	UserAgent UserAgent `json:"User-Agent"`

	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`

	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`
}

// ArtifactParams defines parameters for Artifact.
type ArtifactParams struct {
	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`

	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`
}

// GetFileParams defines parameters for GetFile.
type GetFileParams struct {
	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`

	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`
}

// UploadBeginParams defines parameters for UploadBegin.
type UploadBeginParams struct {
	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`

	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`
}

// UploadCompleteParams defines parameters for UploadComplete.
type UploadCompleteParams struct {
	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`

	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`
}

// UploadChunkParams defines parameters for UploadChunk.
type UploadChunkParams struct {
	// XChunkSHA2 the SHA256 hash of the body contents for this request
	XChunkSHA2 string `json:"X-Chunk-SHA2"`

	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`

	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`
}

// StatusParams defines parameters for Status.
type StatusParams struct {
	// XRequestId The request tracking ID for APM.
	XRequestId *RequestId `json:"X-Request-Id,omitempty"`

	// ElasticApiVersion The API version to use, format should be "YYYY-MM-DD"
	ElasticApiVersion *ApiVersion `json:"elastic-api-version,omitempty"`
}

// AgentEnrollJSONRequestBody defines body for AgentEnroll for application/json ContentType.
type AgentEnrollJSONRequestBody = EnrollRequest

// AgentAcksJSONRequestBody defines body for AgentAcks for application/json ContentType.
type AgentAcksJSONRequestBody = AckRequest

// AgentCheckinJSONRequestBody defines body for AgentCheckin for application/json ContentType.
type AgentCheckinJSONRequestBody = CheckinRequest

// UploadBeginJSONRequestBody defines body for UploadBegin for application/json ContentType.
type UploadBeginJSONRequestBody = UploadBeginRequest

// UploadCompleteJSONRequestBody defines body for UploadComplete for application/json ContentType.
type UploadCompleteJSONRequestBody = UploadCompleteRequest

// Getter for additional properties for UploadBeginRequest. Returns the specified
// element and whether it was found
func (a UploadBeginRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UploadBeginRequest
func (a *UploadBeginRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UploadBeginRequest to handle AdditionalProperties
func (a *UploadBeginRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["action_id"]; found {
		err = json.Unmarshal(raw, &a.ActionId)
		if err != nil {
			return fmt.Errorf("error reading 'action_id': %w", err)
		}
		delete(object, "action_id")
	}

	if raw, found := object["agent_id"]; found {
		err = json.Unmarshal(raw, &a.AgentId)
		if err != nil {
			return fmt.Errorf("error reading 'agent_id': %w", err)
		}
		delete(object, "agent_id")
	}

	if raw, found := object["file"]; found {
		err = json.Unmarshal(raw, &a.File)
		if err != nil {
			return fmt.Errorf("error reading 'file': %w", err)
		}
		delete(object, "file")
	}

	if raw, found := object["src"]; found {
		err = json.Unmarshal(raw, &a.Src)
		if err != nil {
			return fmt.Errorf("error reading 'src': %w", err)
		}
		delete(object, "src")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UploadBeginRequest to handle AdditionalProperties
func (a UploadBeginRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["action_id"], err = json.Marshal(a.ActionId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'action_id': %w", err)
	}

	object["agent_id"], err = json.Marshal(a.AgentId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'agent_id': %w", err)
	}

	object["file"], err = json.Marshal(a.File)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'file': %w", err)
	}

	object["src"], err = json.Marshal(a.Src)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'src': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UploadBeginRequest_File. Returns the specified
// element and whether it was found
func (a UploadBeginRequest_File) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UploadBeginRequest_File
func (a *UploadBeginRequest_File) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UploadBeginRequest_File to handle AdditionalProperties
func (a *UploadBeginRequest_File) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Compression"]; found {
		err = json.Unmarshal(raw, &a.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'Compression': %w", err)
		}
		delete(object, "Compression")
	}

	if raw, found := object["hash"]; found {
		err = json.Unmarshal(raw, &a.Hash)
		if err != nil {
			return fmt.Errorf("error reading 'hash': %w", err)
		}
		delete(object, "hash")
	}

	if raw, found := object["mime_type"]; found {
		err = json.Unmarshal(raw, &a.MimeType)
		if err != nil {
			return fmt.Errorf("error reading 'mime_type': %w", err)
		}
		delete(object, "mime_type")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["size"]; found {
		err = json.Unmarshal(raw, &a.Size)
		if err != nil {
			return fmt.Errorf("error reading 'size': %w", err)
		}
		delete(object, "size")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UploadBeginRequest_File to handle AdditionalProperties
func (a UploadBeginRequest_File) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Compression != nil {
		object["Compression"], err = json.Marshal(a.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'Compression': %w", err)
		}
	}

	if a.Hash != nil {
		object["hash"], err = json.Marshal(a.Hash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hash': %w", err)
		}
	}

	object["mime_type"], err = json.Marshal(a.MimeType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'mime_type': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["size"], err = json.Marshal(a.Size)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'size': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsGenericEvent returns the union data inside the AckRequest_Events_Item as a GenericEvent
func (t AckRequest_Events_Item) AsGenericEvent() (GenericEvent, error) {
	var body GenericEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenericEvent overwrites any union data inside the AckRequest_Events_Item as the provided GenericEvent
func (t *AckRequest_Events_Item) FromGenericEvent(v GenericEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenericEvent performs a merge with any union data inside the AckRequest_Events_Item, using the provided GenericEvent
func (t *AckRequest_Events_Item) MergeGenericEvent(v GenericEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpgradeEvent returns the union data inside the AckRequest_Events_Item as a UpgradeEvent
func (t AckRequest_Events_Item) AsUpgradeEvent() (UpgradeEvent, error) {
	var body UpgradeEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpgradeEvent overwrites any union data inside the AckRequest_Events_Item as the provided UpgradeEvent
func (t *AckRequest_Events_Item) FromUpgradeEvent(v UpgradeEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpgradeEvent performs a merge with any union data inside the AckRequest_Events_Item, using the provided UpgradeEvent
func (t *AckRequest_Events_Item) MergeUpgradeEvent(v UpgradeEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiagnosticsEvent returns the union data inside the AckRequest_Events_Item as a DiagnosticsEvent
func (t AckRequest_Events_Item) AsDiagnosticsEvent() (DiagnosticsEvent, error) {
	var body DiagnosticsEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiagnosticsEvent overwrites any union data inside the AckRequest_Events_Item as the provided DiagnosticsEvent
func (t *AckRequest_Events_Item) FromDiagnosticsEvent(v DiagnosticsEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiagnosticsEvent performs a merge with any union data inside the AckRequest_Events_Item, using the provided DiagnosticsEvent
func (t *AckRequest_Events_Item) MergeDiagnosticsEvent(v DiagnosticsEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInputEvent returns the union data inside the AckRequest_Events_Item as a InputEvent
func (t AckRequest_Events_Item) AsInputEvent() (InputEvent, error) {
	var body InputEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInputEvent overwrites any union data inside the AckRequest_Events_Item as the provided InputEvent
func (t *AckRequest_Events_Item) FromInputEvent(v InputEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInputEvent performs a merge with any union data inside the AckRequest_Events_Item, using the provided InputEvent
func (t *AckRequest_Events_Item) MergeInputEvent(v InputEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AckRequest_Events_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AckRequest_Events_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsActionPolicyReassign returns the union data inside the Action_Data as a ActionPolicyReassign
func (t Action_Data) AsActionPolicyReassign() (ActionPolicyReassign, error) {
	var body ActionPolicyReassign
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionPolicyReassign overwrites any union data inside the Action_Data as the provided ActionPolicyReassign
func (t *Action_Data) FromActionPolicyReassign(v ActionPolicyReassign) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionPolicyReassign performs a merge with any union data inside the Action_Data, using the provided ActionPolicyReassign
func (t *Action_Data) MergeActionPolicyReassign(v ActionPolicyReassign) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionPolicyChange returns the union data inside the Action_Data as a ActionPolicyChange
func (t Action_Data) AsActionPolicyChange() (ActionPolicyChange, error) {
	var body ActionPolicyChange
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionPolicyChange overwrites any union data inside the Action_Data as the provided ActionPolicyChange
func (t *Action_Data) FromActionPolicyChange(v ActionPolicyChange) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionPolicyChange performs a merge with any union data inside the Action_Data, using the provided ActionPolicyChange
func (t *Action_Data) MergeActionPolicyChange(v ActionPolicyChange) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionUpgrade returns the union data inside the Action_Data as a ActionUpgrade
func (t Action_Data) AsActionUpgrade() (ActionUpgrade, error) {
	var body ActionUpgrade
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionUpgrade overwrites any union data inside the Action_Data as the provided ActionUpgrade
func (t *Action_Data) FromActionUpgrade(v ActionUpgrade) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionUpgrade performs a merge with any union data inside the Action_Data, using the provided ActionUpgrade
func (t *Action_Data) MergeActionUpgrade(v ActionUpgrade) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionUnenroll returns the union data inside the Action_Data as a ActionUnenroll
func (t Action_Data) AsActionUnenroll() (ActionUnenroll, error) {
	var body ActionUnenroll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionUnenroll overwrites any union data inside the Action_Data as the provided ActionUnenroll
func (t *Action_Data) FromActionUnenroll(v ActionUnenroll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionUnenroll performs a merge with any union data inside the Action_Data, using the provided ActionUnenroll
func (t *Action_Data) MergeActionUnenroll(v ActionUnenroll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionSettings returns the union data inside the Action_Data as a ActionSettings
func (t Action_Data) AsActionSettings() (ActionSettings, error) {
	var body ActionSettings
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionSettings overwrites any union data inside the Action_Data as the provided ActionSettings
func (t *Action_Data) FromActionSettings(v ActionSettings) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionSettings performs a merge with any union data inside the Action_Data, using the provided ActionSettings
func (t *Action_Data) MergeActionSettings(v ActionSettings) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionCancel returns the union data inside the Action_Data as a ActionCancel
func (t Action_Data) AsActionCancel() (ActionCancel, error) {
	var body ActionCancel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionCancel overwrites any union data inside the Action_Data as the provided ActionCancel
func (t *Action_Data) FromActionCancel(v ActionCancel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionCancel performs a merge with any union data inside the Action_Data, using the provided ActionCancel
func (t *Action_Data) MergeActionCancel(v ActionCancel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionRequestDiagnostics returns the union data inside the Action_Data as a ActionRequestDiagnostics
func (t Action_Data) AsActionRequestDiagnostics() (ActionRequestDiagnostics, error) {
	var body ActionRequestDiagnostics
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionRequestDiagnostics overwrites any union data inside the Action_Data as the provided ActionRequestDiagnostics
func (t *Action_Data) FromActionRequestDiagnostics(v ActionRequestDiagnostics) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionRequestDiagnostics performs a merge with any union data inside the Action_Data, using the provided ActionRequestDiagnostics
func (t *Action_Data) MergeActionRequestDiagnostics(v ActionRequestDiagnostics) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionInputAction returns the union data inside the Action_Data as a ActionInputAction
func (t Action_Data) AsActionInputAction() (ActionInputAction, error) {
	var body ActionInputAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionInputAction overwrites any union data inside the Action_Data as the provided ActionInputAction
func (t *Action_Data) FromActionInputAction(v ActionInputAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionInputAction performs a merge with any union data inside the Action_Data, using the provided ActionInputAction
func (t *Action_Data) MergeActionInputAction(v ActionInputAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Action_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Action_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpgradeMetadataScheduled returns the union data inside the UpgradeDetails_Metadata as a UpgradeMetadataScheduled
func (t UpgradeDetails_Metadata) AsUpgradeMetadataScheduled() (UpgradeMetadataScheduled, error) {
	var body UpgradeMetadataScheduled
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpgradeMetadataScheduled overwrites any union data inside the UpgradeDetails_Metadata as the provided UpgradeMetadataScheduled
func (t *UpgradeDetails_Metadata) FromUpgradeMetadataScheduled(v UpgradeMetadataScheduled) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpgradeMetadataScheduled performs a merge with any union data inside the UpgradeDetails_Metadata, using the provided UpgradeMetadataScheduled
func (t *UpgradeDetails_Metadata) MergeUpgradeMetadataScheduled(v UpgradeMetadataScheduled) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpgradeMetadataDownloading returns the union data inside the UpgradeDetails_Metadata as a UpgradeMetadataDownloading
func (t UpgradeDetails_Metadata) AsUpgradeMetadataDownloading() (UpgradeMetadataDownloading, error) {
	var body UpgradeMetadataDownloading
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpgradeMetadataDownloading overwrites any union data inside the UpgradeDetails_Metadata as the provided UpgradeMetadataDownloading
func (t *UpgradeDetails_Metadata) FromUpgradeMetadataDownloading(v UpgradeMetadataDownloading) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpgradeMetadataDownloading performs a merge with any union data inside the UpgradeDetails_Metadata, using the provided UpgradeMetadataDownloading
func (t *UpgradeDetails_Metadata) MergeUpgradeMetadataDownloading(v UpgradeMetadataDownloading) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpgradeMetadataFailed returns the union data inside the UpgradeDetails_Metadata as a UpgradeMetadataFailed
func (t UpgradeDetails_Metadata) AsUpgradeMetadataFailed() (UpgradeMetadataFailed, error) {
	var body UpgradeMetadataFailed
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpgradeMetadataFailed overwrites any union data inside the UpgradeDetails_Metadata as the provided UpgradeMetadataFailed
func (t *UpgradeDetails_Metadata) FromUpgradeMetadataFailed(v UpgradeMetadataFailed) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpgradeMetadataFailed performs a merge with any union data inside the UpgradeDetails_Metadata, using the provided UpgradeMetadataFailed
func (t *UpgradeDetails_Metadata) MergeUpgradeMetadataFailed(v UpgradeMetadataFailed) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpgradeDetails_Metadata) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpgradeDetails_Metadata) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// retrieve a PGP key from the fleet-server's local storage.
	// (GET /api/agents/upgrades/{major}.{minor}.{patch}/pgp-public-key)
	GetPGPKey(w http.ResponseWriter, r *http.Request, major int, minor int, patch int, params GetPGPKeyParams)

	// (POST /api/fleet/agents/enroll)
	AgentEnroll(w http.ResponseWriter, r *http.Request, params AgentEnrollParams)

	// (POST /api/fleet/agents/{id}/acks)
	AgentAcks(w http.ResponseWriter, r *http.Request, id string, params AgentAcksParams)

	// (POST /api/fleet/agents/{id}/checkin)
	AgentCheckin(w http.ResponseWriter, r *http.Request, id string, params AgentCheckinParams)

	// (GET /api/fleet/artifacts/{id}/{sha2})
	Artifact(w http.ResponseWriter, r *http.Request, id string, sha2 string, params ArtifactParams)
	// retrieve stored file for integration
	// (GET /api/fleet/file/{id})
	GetFile(w http.ResponseWriter, r *http.Request, id string, params GetFileParams)
	// Initiate a file upload process
	// (POST /api/fleet/uploads)
	UploadBegin(w http.ResponseWriter, r *http.Request, params UploadBeginParams)
	// Complete a file upload process
	// (POST /api/fleet/uploads/{id})
	UploadComplete(w http.ResponseWriter, r *http.Request, id string, params UploadCompleteParams)
	// Upload a section of file data
	// (PUT /api/fleet/uploads/{id}/{chunkNum})
	UploadChunk(w http.ResponseWriter, r *http.Request, id string, chunkNum int, params UploadChunkParams)

	// (GET /api/status)
	Status(w http.ResponseWriter, r *http.Request, params StatusParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// retrieve a PGP key from the fleet-server's local storage.
// (GET /api/agents/upgrades/{major}.{minor}.{patch}/pgp-public-key)
func (_ Unimplemented) GetPGPKey(w http.ResponseWriter, r *http.Request, major int, minor int, patch int, params GetPGPKeyParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /api/fleet/agents/enroll)
func (_ Unimplemented) AgentEnroll(w http.ResponseWriter, r *http.Request, params AgentEnrollParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /api/fleet/agents/{id}/acks)
func (_ Unimplemented) AgentAcks(w http.ResponseWriter, r *http.Request, id string, params AgentAcksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /api/fleet/agents/{id}/checkin)
func (_ Unimplemented) AgentCheckin(w http.ResponseWriter, r *http.Request, id string, params AgentCheckinParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /api/fleet/artifacts/{id}/{sha2})
func (_ Unimplemented) Artifact(w http.ResponseWriter, r *http.Request, id string, sha2 string, params ArtifactParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// retrieve stored file for integration
// (GET /api/fleet/file/{id})
func (_ Unimplemented) GetFile(w http.ResponseWriter, r *http.Request, id string, params GetFileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Initiate a file upload process
// (POST /api/fleet/uploads)
func (_ Unimplemented) UploadBegin(w http.ResponseWriter, r *http.Request, params UploadBeginParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Complete a file upload process
// (POST /api/fleet/uploads/{id})
func (_ Unimplemented) UploadComplete(w http.ResponseWriter, r *http.Request, id string, params UploadCompleteParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload a section of file data
// (PUT /api/fleet/uploads/{id}/{chunkNum})
func (_ Unimplemented) UploadChunk(w http.ResponseWriter, r *http.Request, id string, chunkNum int, params UploadChunkParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /api/status)
func (_ Unimplemented) Status(w http.ResponseWriter, r *http.Request, params StatusParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetPGPKey operation middleware
func (siw *ServerInterfaceWrapper) GetPGPKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "major" -------------
	var major int

	err = runtime.BindStyledParameterWithLocation("simple", false, "major", runtime.ParamLocationPath, chi.URLParam(r, "major"), &major)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "major", Err: err})
		return
	}

	// ------------- Path parameter "minor" -------------
	var minor int

	err = runtime.BindStyledParameterWithLocation("simple", false, "minor", runtime.ParamLocationPath, chi.URLParam(r, "minor"), &minor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "minor", Err: err})
		return
	}

	// ------------- Path parameter "patch" -------------
	var patch int

	err = runtime.BindStyledParameterWithLocation("simple", false, "patch", runtime.ParamLocationPath, chi.URLParam(r, "patch"), &patch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "patch", Err: err})
		return
	}

	ctx = context.WithValue(ctx, ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPGPKeyParams

	headers := r.Header

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPGPKey(w, r, major, minor, patch, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AgentEnroll operation middleware
func (siw *ServerInterfaceWrapper) AgentEnroll(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AgentEnrollParams

	headers := r.Header

	// ------------- Required header parameter "User-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("User-Agent")]; found {
		var UserAgent UserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "User-Agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, valueList[0], &UserAgent)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "User-Agent", Err: err})
			return
		}

		params.UserAgent = UserAgent

	} else {
		err := fmt.Errorf("Header parameter User-Agent is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "User-Agent", Err: err})
		return
	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AgentEnroll(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AgentAcks operation middleware
func (siw *ServerInterfaceWrapper) AgentAcks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, AgentApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AgentAcksParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AgentAcks(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AgentCheckin operation middleware
func (siw *ServerInterfaceWrapper) AgentCheckin(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, AgentApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AgentCheckinParams

	headers := r.Header

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, valueList[0], &AcceptEncoding)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Required header parameter "User-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("User-Agent")]; found {
		var UserAgent UserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "User-Agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, valueList[0], &UserAgent)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "User-Agent", Err: err})
			return
		}

		params.UserAgent = UserAgent

	} else {
		err := fmt.Errorf("Header parameter User-Agent is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "User-Agent", Err: err})
		return
	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AgentCheckin(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Artifact operation middleware
func (siw *ServerInterfaceWrapper) Artifact(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "sha2" -------------
	var sha2 string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sha2", runtime.ParamLocationPath, chi.URLParam(r, "sha2"), &sha2)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sha2", Err: err})
		return
	}

	ctx = context.WithValue(ctx, AgentApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ArtifactParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Artifact(w, r, id, sha2, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, AgentApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileParams

	headers := r.Header

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFile(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UploadBegin operation middleware
func (siw *ServerInterfaceWrapper) UploadBegin(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, AgentApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadBeginParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadBegin(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UploadComplete operation middleware
func (siw *ServerInterfaceWrapper) UploadComplete(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, AgentApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadCompleteParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadComplete(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UploadChunk operation middleware
func (siw *ServerInterfaceWrapper) UploadChunk(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "chunkNum" -------------
	var chunkNum int

	err = runtime.BindStyledParameterWithLocation("simple", false, "chunkNum", runtime.ParamLocationPath, chi.URLParam(r, "chunkNum"), &chunkNum)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "chunkNum", Err: err})
		return
	}

	ctx = context.WithValue(ctx, AgentApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadChunkParams

	headers := r.Header

	// ------------- Required header parameter "X-Chunk-SHA2" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Chunk-SHA2")]; found {
		var XChunkSHA2 string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Chunk-SHA2", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Chunk-SHA2", runtime.ParamLocationHeader, valueList[0], &XChunkSHA2)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Chunk-SHA2", Err: err})
			return
		}

		params.XChunkSHA2 = XChunkSHA2

	} else {
		err := fmt.Errorf("Header parameter X-Chunk-SHA2 is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Chunk-SHA2", Err: err})
		return
	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadChunk(w, r, id, chunkNum, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Status operation middleware
func (siw *ServerInterfaceWrapper) Status(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, ApiKeyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params StatusParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "elastic-api-version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("elastic-api-version")]; found {
		var ElasticApiVersion ApiVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "elastic-api-version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, valueList[0], &ElasticApiVersion)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "elastic-api-version", Err: err})
			return
		}

		params.ElasticApiVersion = &ElasticApiVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Status(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/agents/upgrades/{major}.{minor}.{patch}/pgp-public-key", wrapper.GetPGPKey)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/fleet/agents/enroll", wrapper.AgentEnroll)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/fleet/agents/{id}/acks", wrapper.AgentAcks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/fleet/agents/{id}/checkin", wrapper.AgentCheckin)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/fleet/artifacts/{id}/{sha2}", wrapper.Artifact)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/fleet/file/{id}", wrapper.GetFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/fleet/uploads", wrapper.UploadBegin)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/fleet/uploads/{id}", wrapper.UploadComplete)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/fleet/uploads/{id}/{chunkNum}", wrapper.UploadChunk)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/status", wrapper.Status)
	})

	return r
}
